# -*- coding: utf-8 -*-
"""week_2_assignment_5_last.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qsla1QtvbQJWZFNvDj3BWKR3VLEO6Izf
"""

def binary_search_last(numbers, target):
    def inner_search(inner_low, inner_high):
        inner_mid = (inner_low + inner_high)//2
        if target == numbers[inner_mid]:
            results.append(inner_mid)
            return inner_search(inner_mid + 1, inner_high)
        elif inner_high == inner_mid or inner_high -1 == inner_mid:
            return a_bit_larger()
        elif target == numbers[inner_high]:
            results.append(inner_high)
            return results[-1]
        elif target == numbers[inner_low]:
            results.append(inner_low)
            return inner_search(inner_low + 1, inner_high)
        elif target > numbers[inner_high] or target < numbers[inner_low] :
            return a_bit_larger()
        elif target > numbers[inner_mid]:
            return inner_search(inner_mid, inner_high)
        elif target < numbers[inner_mid]:
            return inner_search(inner_low, inner_mid)
        else:
            return a_bit_larger()
    def a_bit_larger():
        if target == numbers[results[-1]]:
            return results[-1]
        else:
            new_target = target + 1
            return binary_search_left(numbers, new_target)
    numbers.sort()
    
    high = len(numbers) - 1
    mid = (high + 1 )//2
    '''
    If len() is not allowed, I will use:

    high = -1
    for i in numbers:
        high += 1
    '''
    
    results = [-1]
    
    if target == numbers[mid]:
        results.append(mid)
        return inner_search(mid + 1, high)
    elif target == numbers[high]:
        return high
    elif target == numbers[0]:
        results.append(0)
        return inner_search(1, high)
    elif target > numbers[high]:
        return high+1
        # this is how bisect.bisect_right will return
    elif target < numbers[0]:
        return 0
    elif target > numbers[mid]:
        return inner_search(mid, high)
    elif target < numbers[mid]:
        return inner_search(0, mid)

numbers = [1, 2, 3, 5, 6, 6, 6, 6, 7, 7, 8,  8,  9,  9,  9,  9,  9,  12, 13, 13, 14, 16, 19, 21, 22, 24, 25, 25, 25, 40, 40, 40, 40, 42, 42, 98, 99, 100]
index_s = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37 ]

import random

for i in range(20):
    target = random.randint(-21, 150)
    try:
        answers = [-1]
        answer = numbers.index(target)
        answers.append(answer)
        while true:
            new_answer = answer + 1
            if numbers[new_answer] == target:
                answers.append(new_answer)
            else: break
    except:
        answer = answers[-1]
    try:
        result = binary_search_last(numbers,target)
        print(result, target, numbers[result])
    except:
        print(result, target, numbers[result -1])

